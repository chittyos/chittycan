# ChittyCan v0.5.0 Architecture Plan

**Target:** Q1 2025 (Bronze Tier ChittyCertified)
**Status:** Planning ‚Üí Implementation
**Last Updated:** 2025-01-04

---

## Executive Summary

v0.5.0 transforms ChittyCan from a **learning system** (v0.4.2) to a **DNA ownership platform** (v0.5.0). This release implements the storage layer, portability infrastructure, and privacy-preserving audit system required for **ChittyFoundation Bronze Tier certification**.

**Key Deliverables:**
1. DNA Vault System (encrypted local storage)
2. PDX v1.0 Implementation (export/import)
3. Privacy-Preserving Audit Trails
4. CLI Commands for DNA Management
5. Foundation Compliance Dashboard

---

## Architecture Overview

### Current State (v0.4.2)

```
User runs commands
    ‚Üì
ChittyCan detects patterns (in-memory)
    ‚Üì
Smart command system routes to tools
    ‚Üì
‚ö†Ô∏è NO PERSISTENCE - learning evaporates on exit
```

**Problems:**
- Learning is ephemeral (no storage)
- No portability (can't export/import)
- No audit trail (privacy violations if we logged raw commands)
- No attribution (can't prove contribution)

### Target State (v0.5.0)

```
User runs commands
    ‚Üì
ChittyCan detects patterns
    ‚Üì
DNA Vault stores encrypted patterns
    ‚Üì
Audit system logs hashes (not content)
    ‚Üì
Attribution engine tracks pattern‚Üíusage‚Üívalue
    ‚Üì
PDX export/import enables portability
```

**Benefits:**
- Learning persists across sessions
- Privacy-preserving audit (hashes only)
- Exportable DNA (PDX format)
- Foundation compliant (Bronze tier)

---

## Component Architecture

### 1. DNA Vault System

**Purpose:** Encrypted local storage for user DNA with git-like versioning.

**Directory Structure:**

```
~/.chittycan/
‚îú‚îÄ‚îÄ config.json               # Existing config (remotes, preferences)
‚îú‚îÄ‚îÄ dna/
‚îÇ   ‚îú‚îÄ‚îÄ vault.enc             # Encrypted DNA storage (AES-256-GCM)
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json         # PDX-compliant metadata
‚îÇ   ‚îú‚îÄ‚îÄ snapshots/            # Versioned DNA history
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2025-01-04T12-00-00Z.dna.enc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2025-01-03T08-30-00Z.dna.enc
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.json        # Snapshot index
‚îÇ   ‚îî‚îÄ‚îÄ keys/
‚îÇ       ‚îú‚îÄ‚îÄ master.key        # User-controlled encryption key
‚îÇ       ‚îî‚îÄ‚îÄ public.pem        # Public key for signatures
‚îú‚îÄ‚îÄ audit/
‚îÇ   ‚îú‚îÄ‚îÄ learning-events.jsonl # Privacy-preserving event log
‚îÇ   ‚îú‚îÄ‚îÄ mutations.jsonl       # DNA change history (hashed)
‚îÇ   ‚îî‚îÄ‚îÄ export-imports.jsonl  # Portability audit trail
‚îî‚îÄ‚îÄ attribution/
    ‚îî‚îÄ‚îÄ chains.jsonl          # Pattern ‚Üí usage ‚Üí impact records
```

**Implementation:**

```typescript
// src/lib/dna-vault.ts

import crypto from 'crypto';
import fs from 'fs-extra';
import path from 'path';
import { CONFIG_DIR } from './config';

const DNA_DIR = path.join(CONFIG_DIR, 'dna');
const VAULT_PATH = path.join(DNA_DIR, 'vault.enc');
const KEY_PATH = path.join(DNA_DIR, 'keys', 'master.key');

export interface ChittyDNA {
  workflows: Workflow[];
  preferences: Record<string, any>;
  command_templates: CommandTemplate[];
  integrations: Integration[];
  context_memory: ContextMemory[];
}

export interface Workflow {
  id: string;
  name: string;
  pattern: {
    type: 'regex' | 'semantic' | 'hybrid';
    value: string;
    hash: string;
  };
  confidence: number;
  usage_count: number;
  success_rate: number;
  created: string; // ISO 8601
  last_evolved: string; // ISO 8601
  impact: {
    time_saved: number; // minutes
  };
  tags: string[];
  privacy: {
    content_hash: string;
    reveal_pattern: boolean;
  };
}

export class DNAVault {
  private static instance: DNAVault;
  private encryptionKey: Buffer;

  private constructor() {
    this.ensureVaultStructure();
    this.encryptionKey = this.loadOrCreateKey();
  }

  static getInstance(): DNAVault {
    if (!DNAVault.instance) {
      DNAVault.instance = new DNAVault();
    }
    return DNAVault.instance;
  }

  private ensureVaultStructure(): void {
    fs.ensureDirSync(path.join(DNA_DIR, 'snapshots'));
    fs.ensureDirSync(path.join(DNA_DIR, 'keys'));
    fs.ensureDirSync(path.join(CONFIG_DIR, 'audit'));
    fs.ensureDirSync(path.join(CONFIG_DIR, 'attribution'));
  }

  private loadOrCreateKey(): Buffer {
    if (fs.existsSync(KEY_PATH)) {
      return fs.readFileSync(KEY_PATH);
    }

    // Generate new 256-bit key
    const key = crypto.randomBytes(32);
    fs.writeFileSync(KEY_PATH, key, { mode: 0o600 }); // User-only read/write
    return key;
  }

  /**
   * Encrypt and save DNA to vault
   */
  async save(dna: ChittyDNA): Promise<void> {
    const json = JSON.stringify(dna, null, 2);
    const encrypted = this.encrypt(json);

    fs.writeFileSync(VAULT_PATH, encrypted);

    // Create snapshot
    await this.snapshot(encrypted);

    // Update manifest
    await this.updateManifest(dna);

    // Log mutation
    await this.logMutation('save', dna);
  }

  /**
   * Load and decrypt DNA from vault
   */
  async load(): Promise<ChittyDNA | null> {
    if (!fs.existsSync(VAULT_PATH)) {
      return null;
    }

    const encrypted = fs.readFileSync(VAULT_PATH);
    const json = this.decrypt(encrypted);

    return JSON.parse(json);
  }

  /**
   * Encrypt data with AES-256-GCM
   */
  private encrypt(data: string): Buffer {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);

    const encrypted = Buffer.concat([
      cipher.update(data, 'utf8'),
      cipher.final()
    ]);

    const authTag = cipher.getAuthTag();

    // Format: [IV (16 bytes)] [Auth Tag (16 bytes)] [Encrypted Data]
    return Buffer.concat([iv, authTag, encrypted]);
  }

  /**
   * Decrypt data with AES-256-GCM
   */
  private decrypt(data: Buffer): string {
    const iv = data.subarray(0, 16);
    const authTag = data.subarray(16, 32);
    const encrypted = data.subarray(32);

    const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);

    return decrypted.toString('utf8');
  }

  /**
   * Create versioned snapshot
   */
  private async snapshot(encryptedData: Buffer): Promise<void> {
    const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, 'Z');
    const snapshotPath = path.join(DNA_DIR, 'snapshots', `${timestamp}.dna.enc`);

    fs.writeFileSync(snapshotPath, encryptedData);

    // Update snapshot index
    const indexPath = path.join(DNA_DIR, 'snapshots', 'index.json');
    const index = fs.existsSync(indexPath)
      ? JSON.parse(fs.readFileSync(indexPath, 'utf8'))
      : { snapshots: [] };

    index.snapshots.push({
      timestamp,
      path: snapshotPath,
      size: encryptedData.length
    });

    // Keep last 30 snapshots
    if (index.snapshots.length > 30) {
      const removed = index.snapshots.shift();
      fs.removeSync(removed.path);
    }

    fs.writeFileSync(indexPath, JSON.stringify(index, null, 2));
  }

  /**
   * Update PDX-compliant manifest
   */
  private async updateManifest(dna: ChittyDNA): Promise<void> {
    const manifestPath = path.join(DNA_DIR, 'manifest.json');

    const manifest = {
      '@context': 'https://foundation.chitty.cc/pdx/v1',
      '@type': 'ChittyDNA',
      version: '1.0.0',
      last_modified: new Date().toISOString(),
      workflow_count: dna.workflows.length,
      template_count: dna.command_templates.length,
      integration_count: dna.integrations.length
    };

    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  }

  /**
   * Log DNA mutation (privacy-preserving)
   */
  private async logMutation(action: string, dna: ChittyDNA): Promise<void> {
    const auditPath = path.join(CONFIG_DIR, 'audit', 'mutations.jsonl');

    const hash = crypto.createHash('sha256')
      .update(JSON.stringify(dna))
      .digest('hex');

    const entry = {
      timestamp: new Date().toISOString(),
      action,
      workflow_count: dna.workflows.length,
      content_hash: hash
    };

    fs.appendFileSync(auditPath, JSON.stringify(entry) + '\n');
  }
}
```

### 2. PDX Export/Import

**Purpose:** Enable portability between ChittyCan and other tools.

**Implementation:**

```typescript
// src/lib/pdx.ts

import crypto from 'crypto';
import { ChittyDNA, Workflow } from './dna-vault';
import { loadConfig } from './config';

export interface PDXExport {
  '@context': string;
  '@type': string;
  version: string;
  owner: {
    chittyid?: string;
    email?: string;
    consent: {
      learning: boolean;
      portability: boolean;
      attribution: boolean;
      marketplace: boolean;
      timestamp: string;
      signature: string;
    };
    license: {
      type: string;
      grant: string;
      scope: string[];
      expires: string | null;
    };
  };
  dna: ChittyDNA;
  attribution?: {
    enabled: boolean;
    contributions: any[];
  };
  metadata: {
    created: string;
    last_modified: string;
    export_timestamp: string;
    export_tool: {
      name: string;
      version: string;
      url: string;
    };
    format_version: string;
    schema_url: string;
    integrity: {
      algorithm: string;
      hash: string;
      signature: string;
    };
  };
}

export type PrivacyMode = 'full' | 'hash-only' | 'zk';

export interface ExportOptions {
  privacy: PrivacyMode;
  includeAttribution: boolean;
  encrypt: boolean;
  password?: string;
}

export async function exportDNA(options: ExportOptions): Promise<PDXExport> {
  const vault = DNAVault.getInstance();
  const dna = await vault.load();

  if (!dna) {
    throw new Error('No DNA found in vault');
  }

  const config = loadConfig();
  const packageJson = require('../../package.json');

  // Apply privacy mode
  const processedDNA = applyPrivacyMode(dna, options.privacy);

  // Generate integrity hash
  const dnaJson = JSON.stringify(processedDNA);
  const hash = crypto.createHash('sha256').update(dnaJson).digest('hex');

  // Sign with private key
  const signature = signData(dnaJson);

  const pdxExport: PDXExport = {
    '@context': 'https://foundation.chitty.cc/pdx/v1',
    '@type': 'ChittyDNA',
    version: '1.0.0',
    owner: {
      email: config.user?.email,
      consent: {
        learning: true,
        portability: true,
        attribution: options.includeAttribution,
        marketplace: false,
        timestamp: new Date().toISOString(),
        signature: signature
      },
      license: {
        type: 'CDCL-1.0',
        grant: 'revocable',
        scope: ['personal'],
        expires: null
      }
    },
    dna: processedDNA,
    metadata: {
      created: dna.workflows[0]?.created || new Date().toISOString(),
      last_modified: new Date().toISOString(),
      export_timestamp: new Date().toISOString(),
      export_tool: {
        name: 'chittycan',
        version: packageJson.version,
        url: 'https://github.com/chittycorp/chittycan'
      },
      format_version: 'pdx-1.0',
      schema_url: 'https://foundation.chitty.cc/pdx/v1/schema.json',
      integrity: {
        algorithm: 'sha256',
        hash,
        signature
      }
    }
  };

  if (options.includeAttribution) {
    pdxExport.attribution = await loadAttribution();
  }

  return pdxExport;
}

function applyPrivacyMode(dna: ChittyDNA, mode: PrivacyMode): ChittyDNA {
  if (mode === 'full') {
    return dna; // No changes
  }

  if (mode === 'hash-only') {
    return {
      ...dna,
      workflows: dna.workflows.map(wf => ({
        ...wf,
        pattern: {
          ...wf.pattern,
          value: wf.pattern.hash // Replace pattern with hash
        },
        privacy: {
          ...wf.privacy,
          reveal_pattern: false
        }
      }))
    };
  }

  throw new Error('ZK mode not yet implemented (v2.0)');
}

function signData(data: string): string {
  // TODO: Implement RSA signature with private key
  const hash = crypto.createHash('sha256').update(data).digest('hex');
  return `0x${hash}`; // Placeholder
}

async function loadAttribution(): Promise<any> {
  // TODO: Load attribution chains from ~/.chittycan/attribution/chains.jsonl
  return {
    enabled: false,
    contributions: []
  };
}

export interface ImportOptions {
  conflictResolution: 'merge' | 'replace' | 'rename' | 'skip';
  verifySignature: boolean;
}

export async function importDNA(
  pdxJson: string,
  options: ImportOptions
): Promise<{ success: boolean; patterns: number; errors: string[] }> {
  const pdx: PDXExport = JSON.parse(pdxJson);

  // Validate schema
  if (pdx['@type'] !== 'ChittyDNA') {
    throw new Error('Invalid PDX file: @type must be ChittyDNA');
  }

  // Verify integrity
  const dnaJson = JSON.stringify(pdx.dna);
  const hash = crypto.createHash('sha256').update(dnaJson).digest('hex');

  if (hash !== pdx.metadata.integrity.hash) {
    throw new Error('Integrity check failed: hash mismatch');
  }

  // Verify signature
  if (options.verifySignature) {
    // TODO: Verify signature with public key
  }

  // Check consent
  if (!pdx.owner.consent.portability) {
    throw new Error('Portability not consented');
  }

  // Load existing DNA
  const vault = DNAVault.getInstance();
  const existingDNA = await vault.load() || {
    workflows: [],
    preferences: {},
    command_templates: [],
    integrations: [],
    context_memory: []
  };

  // Merge workflows
  const { merged, errors } = mergeWorkflows(
    existingDNA.workflows,
    pdx.dna.workflows,
    options.conflictResolution
  );

  const newDNA: ChittyDNA = {
    ...existingDNA,
    workflows: merged,
    preferences: { ...existingDNA.preferences, ...pdx.dna.preferences },
    command_templates: [...existingDNA.command_templates, ...pdx.dna.command_templates],
    integrations: [...existingDNA.integrations, ...pdx.dna.integrations]
  };

  await vault.save(newDNA);

  return {
    success: true,
    patterns: pdx.dna.workflows.length,
    errors
  };
}

function mergeWorkflows(
  existing: Workflow[],
  incoming: Workflow[],
  resolution: string
): { merged: Workflow[]; errors: string[] } {
  const merged = [...existing];
  const errors: string[] = [];

  for (const workflow of incoming) {
    const conflict = existing.find(wf => wf.id === workflow.id);

    if (!conflict) {
      merged.push(workflow);
      continue;
    }

    // Handle conflict
    if (resolution === 'merge') {
      // Combine usage counts, take higher confidence
      merged.push({
        ...workflow,
        usage_count: conflict.usage_count + workflow.usage_count,
        confidence: Math.max(conflict.confidence, workflow.confidence)
      });
    } else if (resolution === 'replace') {
      const index = merged.findIndex(wf => wf.id === workflow.id);
      merged[index] = workflow;
    } else if (resolution === 'rename') {
      merged.push({
        ...workflow,
        id: `${workflow.id}_imported`
      });
    } else if (resolution === 'skip') {
      errors.push(`Skipped conflicting workflow: ${workflow.id}`);
    }
  }

  return { merged, errors };
}
```

### 3. Privacy-Preserving Audit System

**Purpose:** Log learning events and DNA mutations without exposing raw content.

**Implementation:**

```typescript
// src/lib/audit.ts

import fs from 'fs-extra';
import path from 'path';
import crypto from 'crypto';
import { CONFIG_DIR } from './config';

const AUDIT_DIR = path.join(CONFIG_DIR, 'audit');

export type AuditEvent =
  | 'pattern_learned'
  | 'pattern_invoked'
  | 'pattern_evolved'
  | 'dna_exported'
  | 'dna_imported'
  | 'dna_revoked';

export interface AuditEntry {
  timestamp: string;
  event: AuditEvent;
  pattern_hash?: string;
  confidence?: number;
  outcome?: 'success' | 'failure';
  duration_ms?: number;
  metadata?: Record<string, any>;
}

export class AuditLogger {
  private static instance: AuditLogger;

  static getInstance(): AuditLogger {
    if (!AuditLogger.instance) {
      AuditLogger.instance = new AuditLogger();
      fs.ensureDirSync(AUDIT_DIR);
    }
    return AuditLogger.instance;
  }

  /**
   * Log a learning event (privacy-preserving)
   */
  async log(entry: AuditEntry): Promise<void> {
    const logPath = path.join(AUDIT_DIR, 'learning-events.jsonl');

    const logEntry = {
      ...entry,
      timestamp: new Date().toISOString()
    };

    // NEVER log raw content‚Äîonly hashes
    fs.appendFileSync(logPath, JSON.stringify(logEntry) + '\n');
  }

  /**
   * Hash sensitive data before logging
   */
  hash(data: string): string {
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  /**
   * Log pattern learning
   */
  async logPatternLearned(pattern: string, confidence: number): Promise<void> {
    await this.log({
      timestamp: new Date().toISOString(),
      event: 'pattern_learned',
      pattern_hash: this.hash(pattern),
      confidence
    });
  }

  /**
   * Log pattern invocation
   */
  async logPatternInvoked(
    pattern: string,
    outcome: 'success' | 'failure',
    duration_ms: number
  ): Promise<void> {
    await this.log({
      timestamp: new Date().toISOString(),
      event: 'pattern_invoked',
      pattern_hash: this.hash(pattern),
      outcome,
      duration_ms
    });
  }

  /**
   * Log DNA export/import
   */
  async logPortability(
    event: 'dna_exported' | 'dna_imported',
    metadata: Record<string, any>
  ): Promise<void> {
    await this.log({
      timestamp: new Date().toISOString(),
      event,
      metadata
    });
  }
}
```

### 4. CLI Commands for DNA Management

**Purpose:** User-facing commands for DNA ownership and portability.

**Implementation:**

```typescript
// src/commands/dna.ts

import inquirer from 'inquirer';
import fs from 'fs-extra';
import { DNAVault } from '../lib/dna-vault';
import { exportDNA, importDNA } from '../lib/pdx';
import { AuditLogger } from '../lib/audit';

/**
 * Export DNA to PDX format
 */
export async function exportDNACommand(options: {
  privacy: 'full' | 'hash-only';
  output: string;
}): Promise<void> {
  const pdx = await exportDNA({
    privacy: options.privacy,
    includeAttribution: false,
    encrypt: false
  });

  fs.writeFileSync(options.output, JSON.stringify(pdx, null, 2));

  const audit = AuditLogger.getInstance();
  await audit.logPortability('dna_exported', {
    privacy_mode: options.privacy,
    output_path: options.output
  });

  console.log(`‚úì DNA exported to ${options.output}`);
  console.log(`  Privacy mode: ${options.privacy}`);
  console.log(`  Workflows: ${pdx.dna.workflows.length}`);
  console.log(`  Templates: ${pdx.dna.command_templates.length}`);
}

/**
 * Import DNA from PDX file
 */
export async function importDNACommand(options: {
  file: string;
  conflictResolution: 'merge' | 'replace' | 'rename' | 'skip';
}): Promise<void> {
  const pdxJson = fs.readFileSync(options.file, 'utf8');

  const result = await importDNA(pdxJson, {
    conflictResolution: options.conflictResolution,
    verifySignature: true
  });

  const audit = AuditLogger.getInstance();
  await audit.logPortability('dna_imported', {
    source_file: options.file,
    patterns_imported: result.patterns
  });

  console.log(`‚úì Imported ${result.patterns} patterns`);

  if (result.errors.length > 0) {
    console.log(`\n‚ö†Ô∏è  Warnings:`);
    result.errors.forEach(err => console.log(`  ‚Ä¢ ${err}`));
  }
}

/**
 * Show DNA status and statistics
 */
export async function dnaStatusCommand(): Promise<void> {
  const vault = DNAVault.getInstance();
  const dna = await vault.load();

  if (!dna) {
    console.log('No DNA found. Start using ChittyCan to build your DNA!');
    return;
  }

  console.log('\nüß¨ ChittyDNA Status\n');
  console.log(`Workflows learned: ${dna.workflows.length}`);
  console.log(`Command templates: ${dna.command_templates.length}`);
  console.log(`Integrations: ${dna.integrations.length}`);

  const totalUsage = dna.workflows.reduce((sum, wf) => sum + wf.usage_count, 0);
  const avgConfidence = dna.workflows.reduce((sum, wf) => sum + wf.confidence, 0) / dna.workflows.length;
  const totalTimeSaved = dna.workflows.reduce((sum, wf) => sum + wf.impact.time_saved, 0);

  console.log(`\nTotal pattern invocations: ${totalUsage}`);
  console.log(`Average confidence: ${(avgConfidence * 100).toFixed(1)}%`);
  console.log(`Total time saved: ${totalTimeSaved} minutes (${(totalTimeSaved / 60).toFixed(1)} hours)`);

  console.log(`\nüìä Top Patterns:`);
  dna.workflows
    .sort((a, b) => b.usage_count - a.usage_count)
    .slice(0, 5)
    .forEach((wf, i) => {
      console.log(`  ${i + 1}. ${wf.name} (${wf.usage_count} uses, ${(wf.confidence * 100).toFixed(0)}% confidence)`);
    });
}

/**
 * Revoke DNA (ethical exit)
 */
export async function revokeDNACommand(): Promise<void> {
  const { confirm } = await inquirer.prompt([{
    type: 'confirm',
    name: 'confirm',
    message: 'Are you sure you want to revoke your DNA? This will delete all learned patterns.',
    default: false
  }]);

  if (!confirm) {
    console.log('Revocation cancelled.');
    return;
  }

  const vault = DNAVault.getInstance();

  // Create final export for user records
  const pdx = await exportDNA({
    privacy: 'full',
    includeAttribution: true,
    encrypt: false
  });

  const exportPath = `~/chittycan-dna-revoked-${Date.now()}.json`;
  fs.writeFileSync(exportPath, JSON.stringify(pdx, null, 2));

  // Delete vault
  fs.removeSync(path.join(CONFIG_DIR, 'dna'));

  const audit = AuditLogger.getInstance();
  await audit.log({
    timestamp: new Date().toISOString(),
    event: 'dna_revoked'
  });

  console.log(`‚úì DNA revoked`);
  console.log(`‚úì Final export saved to ${exportPath}`);
  console.log(`‚úì All learned patterns deleted`);
}
```

### 5. Foundation Compliance Dashboard

**Purpose:** Generate compliance metrics for Foundation reporting.

**Implementation:**

```typescript
// src/commands/compliance.ts

import { DNAVault } from '../lib/dna-vault';
import { AuditLogger } from '../lib/audit';
import fs from 'fs-extra';
import path from 'path';
import { CONFIG_DIR } from '../lib/config';

export async function complianceReportCommand(): Promise<void> {
  const vault = DNAVault.getInstance();
  const dna = await vault.load();

  const auditPath = path.join(CONFIG_DIR, 'audit', 'learning-events.jsonl');
  const auditEntries = fs.existsSync(auditPath)
    ? fs.readFileSync(auditPath, 'utf8').trim().split('\n').map(line => JSON.parse(line))
    : [];

  const exportImportPath = path.join(CONFIG_DIR, 'audit', 'export-imports.jsonl');
  const portabilityEvents = fs.existsSync(exportImportPath)
    ? fs.readFileSync(exportImportPath, 'utf8').trim().split('\n').map(line => JSON.parse(line))
    : [];

  const report = {
    timestamp: new Date().toISOString(),
    compliance_tier: 'Bronze (In Progress)',
    metrics: {
      // Ownership
      dna_vault_encrypted: true,
      user_controlled_keys: true,

      // Portability
      pdx_version: '1.0.0',
      export_count: portabilityEvents.filter(e => e.event === 'dna_exported').length,
      import_count: portabilityEvents.filter(e => e.event === 'dna_imported').length,
      portability_success_rate: 1.0, // TODO: Calculate from failures

      // Privacy
      audit_trail_enabled: true,
      content_hashing_only: true,
      no_raw_content_logged: true,

      // Attribution
      attribution_enabled: false, // v0.6.0
      trace_chain_completeness: 0, // v0.6.0

      // Safety
      ethical_exit_available: true,
      revocation_count: auditEntries.filter(e => e.event === 'dna_revoked').length,

      // Transparency
      open_source_core: true,
      public_compliance_dashboard: false // TODO: v0.5.0
    },
    dna_stats: {
      workflows: dna?.workflows.length || 0,
      total_usage: dna?.workflows.reduce((sum, wf) => sum + wf.usage_count, 0) || 0,
      avg_confidence: dna?.workflows.reduce((sum, wf) => sum + wf.confidence, 0) / (dna?.workflows.length || 1) || 0
    },
    audit_stats: {
      total_events: auditEntries.length,
      patterns_learned: auditEntries.filter(e => e.event === 'pattern_learned').length,
      patterns_invoked: auditEntries.filter(e => e.event === 'pattern_invoked').length,
      patterns_evolved: auditEntries.filter(e => e.event === 'pattern_evolved').length
    }
  };

  console.log('\nüìä ChittyFoundation Compliance Report\n');
  console.log(JSON.stringify(report, null, 2));

  // Save report
  const reportPath = path.join(CONFIG_DIR, `compliance-report-${Date.now()}.json`);
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

  console.log(`\n‚úì Report saved to ${reportPath}`);
}
```

---

## CLI Command Updates

Add to `src/index.ts`:

```typescript
import {
  exportDNACommand,
  importDNACommand,
  dnaStatusCommand,
  revokeDNACommand
} from './commands/dna.js';
import { complianceReportCommand } from './commands/compliance.js';

yargs(args)
  .command(
    'dna',
    'Manage your ChittyDNA (ownership, portability, attribution)',
    (yargs) =>
      yargs
        .command(
          'export',
          'Export DNA in PDX format',
          (yargs) =>
            yargs
              .option('privacy', {
                type: 'string',
                choices: ['full', 'hash-only'],
                default: 'full',
                description: 'Privacy mode'
              })
              .option('output', {
                type: 'string',
                default: '~/chittycan-dna.json',
                description: 'Output file path'
              }),
          (argv) => { exportDNACommand(argv); }
        )
        .command(
          'import <file>',
          'Import DNA from PDX file',
          (yargs) =>
            yargs
              .positional('file', { type: 'string', demandOption: true })
              .option('conflict-resolution', {
                type: 'string',
                choices: ['merge', 'replace', 'rename', 'skip'],
                default: 'merge'
              }),
          (argv) => { importDNACommand(argv); }
        )
        .command('status', 'Show DNA statistics', () => {}, () => { dnaStatusCommand(); })
        .command('revoke', 'Revoke DNA (ethical exit)', () => {}, () => { revokeDNACommand(); }),
    () => { yargs.showHelp(); }
  )
  .command(
    'compliance',
    'Generate Foundation compliance report',
    () => {},
    () => { complianceReportCommand(); }
  );
```

---

## Testing Strategy

### Unit Tests

```bash
npm run test:unit
```

**Coverage:**
- DNA vault encryption/decryption
- PDX export/import validation
- Conflict resolution strategies
- Audit logging (no content leakage)

### Integration Tests

```bash
npm run test:integration
```

**Scenarios:**
1. Learn pattern ‚Üí save to vault ‚Üí export ‚Üí import ‚Üí verify integrity
2. Export with hash-only privacy ‚Üí verify no raw content
3. Import with conflicts ‚Üí test merge/replace/rename/skip
4. Revoke DNA ‚Üí verify complete deletion + export

### Foundation Compliance Tests

```bash
npm run test:compliance
```

**Checks:**
- Portability: Can export/import without data loss
- Privacy: No raw content in audit logs
- Ownership: User controls encryption keys
- Ethical Exit: Revocation deletes all DNA
- Transparency: Compliance report generates correctly

---

## Security Considerations

### Threat Model

| Threat | Mitigation |
|--------|-----------|
| DNA theft (unauthorized export) | Signature verification + rate limiting |
| Key compromise | User-controlled keys (not stored in cloud) |
| Audit log privacy leak | Hash-only logging, no raw content |
| Tampered imports | Integrity hash + signature validation |
| Pattern extraction | Export cooldown (1 per 24 hours) |

### Encryption

- **Algorithm:** AES-256-GCM (authenticated encryption)
- **Key Management:** User-controlled keys in `~/.chittycan/dna/keys/`
- **Key Permissions:** `0o600` (user read/write only)
- **IV:** Randomly generated per encryption (16 bytes)
- **Auth Tag:** 16 bytes for integrity verification

### Rate Limiting

- **Export:** 1 export per 24 hours (Bronze tier)
- **Import:** Max 100 patterns per import (prevents bulk scraping)
- **Override:** Manual request to Foundation for emergency exports

---

## Migration Path from v0.4.2 ‚Üí v0.5.0

### Automatic Migration

When user upgrades to v0.5.0:

1. **Detect first run:**
   ```typescript
   if (!fs.existsSync(DNA_DIR)) {
     console.log('üÜï Welcome to v0.5.0!');
     console.log('Initializing DNA vault...');
     initializeVault();
   }
   ```

2. **Initialize vault structure:**
   ```bash
   ~/.chittycan/dna/
   ```

3. **Generate encryption key:**
   ```bash
   ~/.chittycan/dna/keys/master.key
   ```

4. **Show migration message:**
   ```
   ‚úì DNA vault initialized
   ‚úì Encryption key generated

   Your ChittyDNA is now stored locally and encrypted.
   You own your data. Export anytime with: can dna export

   Learn more: https://foundation.chitty.cc/charter
   ```

### No Breaking Changes

- Existing config.json remains unchanged
- Remotes continue to work
- All existing commands work as before

---

## Release Checklist

- [ ] Implement DNA Vault (`src/lib/dna-vault.ts`)
- [ ] Implement PDX export/import (`src/lib/pdx.ts`)
- [ ] Implement Audit Logger (`src/lib/audit.ts`)
- [ ] Implement DNA commands (`src/commands/dna.ts`)
- [ ] Implement compliance reporting (`src/commands/compliance.ts`)
- [ ] Write unit tests (>80% coverage)
- [ ] Write integration tests (export/import cycles)
- [ ] Write compliance tests (Foundation requirements)
- [ ] Update README with DNA ownership section
- [ ] Create FOUNDATION.md and PDX_SPEC.md
- [ ] Build and test locally
- [ ] Deploy staging release (v0.5.0-beta)
- [ ] User testing (5+ testers)
- [ ] Security audit (encryption, audit logs)
- [ ] Foundation review and Bronze tier certification
- [ ] Production release (v0.5.0)
- [ ] Publish to npm
- [ ] Announce on GitHub, Twitter, Foundation channels

---

## Success Metrics

**Bronze Tier Certification:**
- ‚úÖ DNA vault encryption (AES-256-GCM)
- ‚úÖ PDX export/import (v1.0 spec)
- ‚úÖ Privacy-preserving audit (hash-only logs)
- ‚úÖ Ethical exit (revocation + export)
- ‚úÖ User-controlled keys
- ‚úÖ Compliance dashboard

**User Metrics:**
- Export success rate: >99%
- Import success rate: >95%
- DNA persistence: 100% across sessions
- Portability: Cross-tool import (Cursor, Claude Code)

---

**Estimated Timeline:**
- Week 1-2: Core vault + PDX implementation
- Week 3: Audit + compliance systems
- Week 4: CLI commands + testing
- Week 5: Security audit + Foundation review
- Week 6: Beta release + user testing
- Week 7: Production release + certification

**Target Release:** End of Q1 2025
